{
    "python": "class Solution:\n    def myAtoi(self, s: str) -> int:\n        # Define the 32-bit signed integer range.\n        # 2**31 - 1 = 2147483647\n        INT_MAX = 2**31 - 1\n        # -2**31 = -2147483648\n        INT_MIN = -2**31\n\n        i = 0\n        n = len(s)\n\n        # 1. Ignore any leading whitespace.\n        # We advance the index `i` as long as it's within the string bounds and the character is a space.\n        while i < n and s[i] == ' ':\n            i += 1\n\n        # 2. Determine the sign by checking the next character (if it exists).\n        sign = 1\n        if i < n and (s[i] == '+' or s[i] == '-'):\n            if s[i] == '-':\n                sign = -1\n            # Move past the sign character.\n            i += 1\n\n        # 3. Convert digits and handle overflow.\n        result = 0\n        while i < n and s[i].isdigit():\n            digit = int(s[i])\n\n            # This is the crucial overflow check.\n            # We are about to compute `result = result * 10 + digit`.\n            # To avoid exceeding the 32-bit integer limits, we check for potential overflow beforehand.\n            # The check is: `result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7)`\n            # where INT_MAX // 10 is 214748364 and the last digit of INT_MAX is 7.\n            \n            # For a positive number, overflow happens if `result * 10 + digit > INT_MAX`.\n            # - If `result > 214748364`, `result * 10` will overflow.\n            # - If `result == 214748364`, overflow occurs if `digit > 7`.\n            \n            # This check also handles negative underflow. We are checking if `-(result * 10 + digit) < INT_MIN`,\n            # which is `result * 10 + digit > -INT_MIN` (i.e., > 2147483648).\n            # Our check correctly identifies numbers that would exceed `2147483647`.\n            # This covers all positive overflows and all negative underflows. For the specific case of INT_MIN (-2147483648),\n            # when `result` is 214748364 and `digit` is 8, `digit > 7` is true, so we correctly return `INT_MIN`.\n            if result > INT_MAX // 10 or (result == INT_MAX // 10 and digit > 7):\n                return INT_MAX if sign == 1 else INT_MIN\n\n            result = result * 10 + digit\n            i += 1\n\n        # 4. Apply the sign and return the final result.\n        return sign * result\n",
    "java": "class Solution {\n    public int myAtoi(String s) {\n        if (s == null) {\n            return 0;\n        }\n\n        int i = 0;\n        int n = s.length();\n\n        // 1. Ignore any leading whitespace.\n        // We advance the index `i` as long as it's within the string bounds and the character is a space.\n        while (i < n && s.charAt(i) == ' ') {\n            i++;\n        }\n\n        // 2. Determine the sign by checking the next character.\n        int sign = 1;\n        if (i < n && (s.charAt(i) == '+' || s.charAt(i) == '-')) {\n            if (s.charAt(i) == '-') {\n                sign = -1;\n            }\n            i++; // Move past the sign character.\n        }\n\n        // 3. Convert digits and handle overflow.\n        int result = 0;\n        while (i < n && Character.isDigit(s.charAt(i))) {\n            int digit = s.charAt(i) - '0';\n\n            // This is the core logic for overflow detection.\n            // Before we perform `result = result * 10 + digit;`, we must ensure this operation won't cause an overflow.\n            // The check is `result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)`.\n            // Integer.MAX_VALUE is 2147483647. Its last digit is 7.\n\n            // Case 1: Positive number (sign = 1). Overflow if `result * 10 + digit > 2147483647`.\n            // - If `result > 214748364`, `result * 10` is at least `2147483650`, causing overflow.\n            // - If `result == 214748364`, `result * 10 + digit` overflows if `digit > 7`.\n\n            // Case 2: Negative number (sign = -1). Underflow if `-(result * 10 + digit) < -2147483648`.\n            // This is equivalent to `result * 10 + digit > 2147483648`.\n            // Our check correctly identifies numbers that would exceed `2147483647`.\n            // For example, for \"-2147483648\", when `result` is `214748364` and `digit` is `8`,\n            // `digit > 7` is true, so we correctly return `Integer.MIN_VALUE`.\n            if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > 7)) {\n                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            }\n\n            result = result * 10 + digit;\n            i++;\n        }\n\n        // 4. Apply the sign and return the final result.\n        return sign * result;\n    }\n}\n",
    "cpp": "#include <string>\n#include <climits> // For INT_MAX, INT_MIN\n#include <cctype>  // For isdigit\n\nclass Solution {\npublic:\n    int myAtoi(std::string s) {\n        int i = 0;\n        int n = s.length();\n\n        // 1. Ignore any leading whitespace.\n        // We advance the index `i` as long as it's within the string bounds and the character is a space.\n        while (i < n && s[i] == ' ') {\n            i++;\n        }\n\n        // 2. Determine the sign by checking the next character.\n        int sign = 1;\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            if (s[i] == '-') {\n                sign = -1;\n            }\n            i++; // Move past the sign character.\n        }\n\n        // 3. Convert digits and handle overflow.\n        int result = 0;\n        while (i < n && isdigit(s[i])) {\n            int digit = s[i] - '0';\n\n            // This is the core logic for overflow detection.\n            // Before we perform `result = result * 10 + digit;`, we must ensure this operation won't cause an overflow.\n            // The check is `result > INT_MAX / 10 || (result == INT_MAX / 10 && digit > 7)`.\n            // INT_MAX is 2147483647. Its last digit is 7.\n\n            // Case 1: Positive number (sign = 1). Overflow if `result * 10 + digit > 2147483647`.\n            // - If `result > 214748364`, `result * 10` is at least `2147483650`, causing overflow.\n            // - If `result == 214748364`, `result * 10 + digit` overflows if `digit > 7`.\n\n            // Case 2: Negative number (sign = -1). Underflow if `-(result * 10 + digit) < -2147483648`.\n            // This is equivalent to `result * 10 + digit > 2147483648`.\n            // Our check correctly identifies numbers that would exceed `2147483647`.\n            // For example, for \"-2147483648\", when `result` is `214748364` and `digit` is `8`,\n            // `digit > 7` is true, so we correctly return `INT_MIN`.\n            if (result > INT_MAX / 10 || (result == INT_MAX / 10 && digit > 7)) {\n                return sign == 1 ? INT_MAX : INT_MIN;\n            }\n\n            result = result * 10 + digit;\n            i++;\n        }\n\n        // 4. Apply the sign and return the final result.\n        return sign * result;\n    }\n};\n"
}