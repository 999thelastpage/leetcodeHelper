{
    "python": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # We use dynamic programming to solve this problem.\n        # Let dp[i][j] be a boolean value indicating whether the first i characters of s\n        # match the first j characters of p.\n        # The size of our DP table will be (len(s) + 1) x (len(p) + 1).\n\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n\n        # Base Case: An empty pattern matches an empty string.\n        # dp[0][0] represents s[:0] and p[:0], which are both empty.\n        dp[0][0] = True\n\n        # Handle patterns that can match an empty string, like 'a*', 'a*b*', '.*'.\n        # This populates the first row of the DP table.\n        # A pattern can match an empty string only if it consists of characters\n        # followed by '*' and the pattern without these two characters also matches\n        # an empty string.\n        for j in range(1, n + 1):\n            if p[j - 1] == '*':\n                # p[j-1] is '*', it can match zero of the preceding element (p[j-2]).\n                # So, dp[0][j] depends on whether the pattern p[:j-2] matches an empty string.\n                # Note: The problem guarantees a valid char before '*', so j-2 is safe.\n                dp[0][j] = dp[0][j - 2]\n\n        # Fill the rest of the DP table.\n        # i represents the length of the prefix of s (from 1 to m).\n        # j represents the length of the prefix of p (from 1 to n).\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # Case 1: The current character in the pattern p is NOT '*'.\n                # It's either a normal character or '.'.\n                if p[j - 1] != '*':\n                    # For a match, the previous substrings must match (dp[i-1][j-1])\n                    # AND the current characters must match.\n                    # Current characters match if p[j-1] is '.' (matches any char)\n                    # or if p[j-1] is the same as s[i-1].\n                    if dp[i - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == '.'):\n                        dp[i][j] = True\n                # Case 2: The current character in the pattern p IS '*'.\n                else: # p[j-1] == '*'\n                    # The '*' matches zero or more of the preceding element p[j-2].\n\n                    # Subcase 2a: '*' matches ZERO of the preceding element.\n                    # In this case, we effectively ignore the `p[j-2]*` part of the pattern.\n                    # The result is then dependent on whether s[:i] matches p[:j-2].\n                    if dp[i][j - 2]:\n                        dp[i][j] = True\n                    # Subcase 2b: '*' matches ONE OR MORE of the preceding element.\n                    # This is only possible if the current character of s (s[i-1]) matches\n                    # the character preceding '*' in p (p[j-2]).\n                    # If they match, the result depends on whether the pattern p[:j] could match\n                    # the string s up to its previous character, s[:i-1]. This is dp[i-1][j].\n                    # For example, if s=\"aa\" and p=\"a*\", dp[2][2] for s=\"aa\" vs p=\"a*\"\n                    # depends on dp[1][2] for s=\"a\" vs p=\"a*\".\n                    elif dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'):\n                        dp[i][j] = True\n\n        # The final result is in dp[m][n], which tells if the entire string s\n        # matches the entire pattern p.\n        return dp[m][n]\n",
    "java": "class Solution {\n    public boolean isMatch(String s, String p) {\n        // We use dynamic programming to solve this problem.\n        // Let dp[i][j] be a boolean value indicating whether the first i characters of s\n        // match the first j characters of p.\n        // The size of our DP table will be (s.length() + 1) x (p.length() + 1).\n        int m = s.length();\n        int n = p.length();\n\n        boolean[][] dp = new boolean[m + 1][n + 1];\n\n        // Base Case: An empty pattern matches an empty string.\n        // dp[0][0] represents s[:0] and p[:0], which are both empty.\n        dp[0][0] = true;\n\n        // Handle patterns that can match an empty string, like 'a*', 'a*b*', '.*'.\n        // This populates the first row of the DP table.\n        // A pattern can match an empty string only if it consists of characters\n        // followed by '*' and the pattern without these two characters also matches\n        // an empty string.\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                // p.charAt(j-1) is '*', it can match zero of the preceding element (p.charAt(j-2)).\n                // So, dp[0][j] depends on whether the pattern p up to j-2 matches an empty string.\n                // The problem guarantees a valid char before '*', so j-2 is safe (j starts at 1, but this branch is only taken if j>=2 because p[j-1]=='*').\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n\n        // Fill the rest of the DP table.\n        // i corresponds to the length of the prefix of s (from 1 to m).\n        // j corresponds to the length of the prefix of p (from 1 to n).\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                // Case 1: The current character in the pattern p is NOT '*'.\n                // It's either a normal character or '.'.\n                if (p.charAt(j - 1) != '*') {\n                    // For a match, the previous substrings must match (dp[i-1][j-1])\n                    // AND the current characters must match.\n                    // Current characters match if p.charAt(j-1) is '.' (matches any char)\n                    // or if p.charAt(j-1) is the same as s.charAt(i-1).\n                    if (dp[i - 1][j - 1] && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')) {\n                        dp[i][j] = true;\n                    }\n                } else { // p.charAt(j-1) == '*'\n                    // Case 2: The current character in the pattern p IS '*'.\n                    // The '*' matches zero or more of the preceding element p.charAt(j-2).\n\n                    // Subcase 2a: '*' matches ZERO of the preceding element.\n                    // In this case, we effectively ignore the `p[j-2]*` part of the pattern.\n                    // The result is then dependent on whether s[:i] matches p[:j-2].\n                    if (dp[i][j - 2]) {\n                        dp[i][j] = true;\n                    }\n                    // Subcase 2b: '*' matches ONE OR MORE of the preceding element.\n                    // This is only possible if the current character of s (s[i-1]) matches\n                    // the character preceding '*' in p (p[j-2]).\n                    // If they match, the result depends on whether the pattern p[:j] could match\n                    // the string s up to its previous character, s[:i-1]. This is dp[i-1][j].\n                    // For example, if s=\"aa\" and p=\"a*\", dp[2][2] for s=\"aa\" vs p=\"a*\"\n                    // depends on dp[1][2] for s=\"a\" vs p=\"a*\".\n                    else if (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.')) {\n                        dp[i][j] = true;\n                    }\n                }\n            }\n        }\n\n        // The final result is in dp[m][n], which tells if the entire string s\n        // matches the entire pattern p.\n        return dp[m][n];\n    }\n}\n",
    "cpp": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        // We use dynamic programming to solve this problem.\n        // Let dp[i][j] be a boolean value indicating whether the first i characters of s\n        // match the first j characters of p.\n        // The size of our DP table will be (s.length() + 1) x (p.length() + 1).\n        int m = s.length();\n        int n = p.length();\n\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n\n        // Base Case: An empty pattern matches an empty string.\n        // dp[0][0] represents s[:0] and p[:0], which are both empty.\n        dp[0][0] = true;\n\n        // Handle patterns that can match an empty string, like 'a*', 'a*b*', '.*'.\n        // This populates the first row of the DP table.\n        // A pattern can match an empty string only if it consists of characters\n        // followed by '*' and the pattern without these two characters also matches\n        // an empty string.\n        for (int j = 1; j <= n; ++j) {\n            if (p[j - 1] == '*') {\n                // p[j-1] is '*', it can match zero of the preceding element (p[j-2]).\n                // So, dp[0][j] depends on whether the pattern p up to j-2 matches an empty string.\n                // The problem guarantees a valid char before '*', so j-2 is safe.\n                // Note j=1 p[0]=='*' is not possible due to constraints, so j>=2 for this to be true.\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n\n        // Fill the rest of the DP table.\n        // i corresponds to the length of the prefix of s (from 1 to m).\n        // j corresponds to the length of the prefix of p (from 1 to n).\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                // Case 1: The current character in the pattern p is NOT '*'.\n                // It's either a normal character or '.'.\n                if (p[j - 1] != '*') {\n                    // For a match, the previous substrings must match (dp[i-1][j-1])\n                    // AND the current characters must match.\n                    // Current characters match if p[j-1] is '.' (matches any char)\n                    // or if p[j-1] is the same as s[i-1].\n                    if (dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '.')) {\n                        dp[i][j] = true;\n                    }\n                } else { // p[j-1] == '*'\n                    // Case 2: The current character in the pattern p IS '*'.\n                    // The '*' matches zero or more of the preceding element p[j-2].\n\n                    // Subcase 2a: '*' matches ZERO of the preceding element.\n                    // In this case, we effectively ignore the `p[j-2]*` part of the pattern.\n                    // The result is then dependent on whether s[:i] matches p[:j-2].\n                    if (dp[i][j - 2]) {\n                        dp[i][j] = true;\n                    }\n                    // Subcase 2b: '*' matches ONE OR MORE of the preceding element.\n                    // This is only possible if the current character of s (s[i-1]) matches\n                    // the character preceding '*' in p (p[j-2]).\n                    // If they match, the result depends on whether the pattern p[:j] could match\n                    // the string s up to its previous character, s[:i-1]. This is dp[i-1][j].\n                    // For example, if s=\"aa\" and p=\"a*\", dp[2][2] for s=\"aa\" vs p=\"a*\"\n                    // depends on dp[1][2] for s=\"a\" vs p=\"a*\".\n                    else if (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')) {\n                        dp[i][j] = true;\n                    }\n                }\n            }\n        }\n\n        // The final result is in dp[m][n], which tells if the entire string s\n        // matches the entire pattern p.\n        return dp[m][n];\n    }\n};\n"
}