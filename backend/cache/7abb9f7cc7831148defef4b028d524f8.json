{
    "python": "class Solution:\n    def twoSum(self, nums: list[int], target: int) -> list[int]:\n        # This problem asks for the indices of two numbers that sum up to a target.\n        # The optimal approach is to use a hash map (dictionary in Python) to achieve\n        # a time complexity of O(n).\n        \n        # The core idea is to iterate through the array once. For each element `num`,\n        # we calculate its `complement` (i.e., `target - num`). Then, we check if this\n        # `complement` has been seen before by looking it up in our hash map.\n\n        # Hash map to store numbers we have seen and their corresponding indices.\n        # Key: number, Value: index.\n        num_to_index = {}\n\n        # We use enumerate to get both the index (i) and the value (num) of each element.\n        for i, num in enumerate(nums):\n            # Calculate the value we need to find to complete the pair.\n            complement = target - num\n\n            # Check if the complement exists in our hash map.\n            # If it does, it means we have already processed the other number of the pair.\n            if complement in num_to_index:\n                # We have found the solution. The index of the complement is stored\n                # in the hash map, and the index of the current number is 'i'.\n                return [num_to_index[complement], i]\n\n            # If the complement is not in the map, it means we haven't seen the other\n            # half of the pair yet. We add the current number and its index to the map.\n            # This prepares for a future element that might need this `num` as its complement.\n            # We add it *after* the check to ensure we don't use the same element twice,\n            # e.g., for `nums = [3, 5, 8]` and `target = 6`, we don't want to match `3` with itself.\n            num_to_index[num] = i\n\n        # According to the problem constraints, a solution always exists, so this part of the\n        # code is technically unreachable. We don't need a return statement here.",
    "java": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // The optimal solution to this problem uses a hash map to store the numbers\n        // we've encountered so far and their indices. This allows us to find the\n        // required complement for each number in O(1) average time.\n\n        // The strategy is a \"one-pass hash table\". We iterate through the array, and for\n        // each element, we check if its complement (target - current element) is already\n        // in the map. If it is, we've found our pair. If not, we add the current\n        // element and its index to the map for future checks.\n\n        // Hash map to store the mapping from a number to its index.\n        Map<Integer, Integer> numToIndex = new HashMap<>();\n\n        // Iterate through the array from beginning to end.\n        for (int i = 0; i < nums.length; i++) {\n            // Calculate the complement needed for the current number.\n            int complement = target - nums[i];\n\n            // Check if the map already contains the complement.\n            // If it does, we have found the two numbers that sum to the target.\n            if (numToIndex.containsKey(complement)) {\n                // The value associated with the complement key is its index.\n                // The current index is 'i'. We return both.\n                return new int[]{numToIndex.get(complement), i};\n            }\n\n            // If the complement is not found, we add the current number and its index\n            // to the map. This is done *after* the check to avoid using the same element\n            // twice and to correctly handle cases like `nums = [3, 3], target = 6`.\n            numToIndex.put(nums[i], i);\n        }\n\n        // The problem statement guarantees exactly one solution, so the loop will always\n        // find a pair and return. This part of the code should be unreachable.\n        // Throwing an exception is a standard way to handle such cases in Java.\n        throw new IllegalArgumentException(\"No two sum solution found\");\n    }\n}",
    "cpp": "#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::vector<int> twoSum(std::vector<int>& nums, int target) {\n        // This solution employs a one-pass hash table (unordered_map in C++) approach,\n        // which provides an optimal time complexity of O(n).\n\n        // The main idea is to iterate through the vector. For each element `nums[i]`, we\n        // calculate the `complement` (i.e., `target - nums[i]`). We then check if this\n        // complement already exists in our hash map. A hash map gives us an average\n        // O(1) time for lookups.\n\n        // The hash map will store numbers we have already seen as keys and their\n        // indices as values.\n        std::unordered_map<int, int> num_to_index;\n\n        // Iterate through the vector using an index.\n        for (int i = 0; i < nums.size(); ++i) {\n            // Calculate the complement for the current element.\n            int complement = target - nums[i];\n\n            // Search for the complement in the hash map.\n            // `find` returns an iterator to the element if found, otherwise it returns `end()`.\n            if (num_to_index.find(complement) != num_to_index.end()) {\n                // If the complement is found, it means we have previously seen the other\n                // number of the pair. We have found our solution.\n                // `num_to_index[complement]` gives the index of the complement, and `i`\n                // is the index of the current number.\n                return {num_to_index[complement], i};\n            }\n\n            // If the complement was not found, we insert the current number and its index\n            // into the map. This makes it available for future elements that might need\n            // it as their complement.\n            // We add it *after* the check to correctly handle cases like `[3, 3]` with\n            // `target = 6` and to not use the same element twice.\n            num_to_index[nums[i]] = i;\n        }\n\n        // The problem guarantees that exactly one solution exists, so the function will\n        // always return from within the loop. This return is to satisfy the compiler,\n        // which may otherwise warn that a non-void function might not return a value.\n        return {};\n    }\n};"
}