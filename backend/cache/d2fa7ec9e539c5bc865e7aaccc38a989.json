{
    "explanation": "## Pattern Analysis\n\nThe problem asks us to find two numbers in an array that add up to a specific target. Let's represent the two numbers as `a` and `b`, and the target as `T`. The core equation is `a + b = T`.\n\nIf we iterate through the array and pick an element, let's call it `nums[i]`, we can consider this to be `a`. The problem then transforms into finding another element `b` in the array such that `b = T - a`. In other words, for each number `x` in the array, we need to efficiently search for its *complement*, `target - x`.\n\nA naive search for the complement for each element would involve another scan of the array, leading to an O(n²) solution. The follow-up question, \"Can you come up with an algorithm that is less than O(n²) time complexity?\", is a strong hint that we need a more efficient way to perform this search.\n\nThis \"search for a complement\" pattern is a classic use case for a **Hash Table** (also known as a Hash Map or Dictionary). A hash table provides an average time complexity of O(1) for lookups, insertions, and deletions. By using a hash table, we can trade some extra space to drastically reduce the time needed to find the complement. Instead of scanning the array repeatedly, we can check for the complement's existence in our hash table in constant time.\n\n## Intuition\n\nLet's build upon the idea of using a hash table. Our goal is to make the lookup for the complement `(target - current_number)` instantaneous.\n\nImagine you're walking through the array, one number at a time. For each number you encounter, you ask a simple question: \"Have I already seen the number that would complete the pair with me?\" \n\nTo answer this question efficiently, you need a way to remember the numbers you've already passed and their original locations (indices). A hash map is perfect for this memory. We can use a map where the **keys** are the numbers from the array and the **values** are their corresponding indices.\n\nLet's trace the logic with an example: `nums = [2, 7, 11, 15]` and `target = 9`.\n\n1.  We start with an empty hash map, let's call it `seen_map`.\n2.  We look at the first number, `nums[0]`, which is `2`. The complement we need is `target - 2 = 9 - 2 = 7`. We ask, \"Is `7` in our `seen_map`?\" No, the map is empty. So, we haven't found the pair yet. What should we do with the number `2`? We should store it in our map in case it's the complement for a future number. We add `{2: 0}` to our `seen_map` (the number `2` is at index `0`).\n3.  We move to the next number, `nums[1]`, which is `7`. The complement we need is `target - 7 = 9 - 7 = 2`. We ask, \"Is `2` in our `seen_map`?\" Yes, it is! The map contains `{2: 0}`.\n4.  Success! We've found our pair. The current number is `7` (at index `1`), and its complement `2` is in the map. The map tells us that `2` is at index `0`. So, the indices of the two numbers are `0` and `1`. We can return `[0, 1]`.\n\nThis single-pass approach is very powerful. For every element, we first check if its complement already exists in the map. If it does, we've found our solution. If not, we add the current element to the map to make it available for future complement searches. This ensures we process the array in a single pass.\n\nThis method also correctly handles the constraint that you may not use the *same* element twice. By checking for the complement *before* adding the current number to the map, we ensure we never match a number with itself. For an input like `nums = [3, 5, 8]`, `target = 6`, when we process `3`, the complement is `3`. We check the map, find it's empty, and then add `{3: 0}`. We don't find a match for `3` with itself.\n\n## Algorithm\n\nHere is a step-by-step description of the optimal one-pass hash table algorithm.\n\n1.  **Initialize a Hash Map:** Create an empty hash map, `num_to_index_map`, to store numbers we have encountered and their corresponding indices. The map will store key-value pairs of the format `{number: index}`.\n\n2.  **Iterate Through the Array:** Loop through the `nums` array from the first element to the last. For each element, we'll get its value, `current_num`, and its index, `i`.\n\n3.  **Calculate the Complement:** For each `current_num`, calculate the value we need to find: `complement = target - current_num`.\n\n4.  **Check the Hash Map:** Look for the `complement` as a key in your `num_to_index_map`.\n    *   **If the `complement` exists in the map:** You have found the solution. The two numbers are `current_num` (at index `i`) and `complement`. The index of the `complement` is stored in the map. You can immediately return an array containing the two indices: `[num_to_index_map[complement], i]`.\n    *   **If the `complement` does not exist in the map:** You haven't found the pair yet. Add the `current_num` and its index `i` to the `num_to_index_map`. This is crucial, as `current_num` might be the complement for a number you'll see later in the array.\n\n5.  **Guaranteed Solution:** The problem statement guarantees that exactly one solution exists, so your function will always find a pair and return from within the loop. No code is needed after the loop.\n\nLet's visualize this with `nums = [3, 2, 4]` and `target = 6`.\n\n*   **Initial state:** `num_to_index_map = {}`\n\n*   **i = 0, current_num = 3:**\n    *   `complement = 6 - 3 = 3`.\n    *   Is `3` in the map? No.\n    *   Add `{3: 0}` to the map. Map is now `{3: 0}`.\n\n*   **i = 1, current_num = 2:**\n    *   `complement = 6 - 2 = 4`.\n    *   Is `4` in the map? No.\n    *   Add `{2: 1}` to the map. Map is now `{3: 0, 2: 1}`.\n\n*   **i = 2, current_num = 4:**\n    *   `complement = 6 - 4 = 2`.\n    *   Is `2` in the map? Yes! `num_to_index_map[2]` is `1`.\n    *   Solution found! The indices are `num_to_index_map[2]` (which is `1`) and the current index `i` (which is `2`).\n    *   Return `[1, 2]`.\n\n## Complexity Analysis\n\n-   **Time Complexity: O(n)**\n    The algorithm involves a single pass through the `nums` array. For each of the `n` elements in the array, we perform a constant number of operations: a subtraction, a hash map lookup, and potentially a hash map insertion. On average, hash map operations take O(1) time. Therefore, the total time complexity is dominated by the single loop, resulting in **O(n)**.\n\n-   **Space Complexity: O(n)**\n    The algorithm uses a hash map to store the numbers encountered. In the worst-case scenario, we might need to store up to `n-1` elements in the hash map before finding the solution (for example, if the two numbers that sum to the target are the last two elements of the array). Thus, the space required is proportional to the number of elements in the input array, making the space complexity **O(n)**. This is the trade-off we make: using extra space to achieve a much faster time complexity compared to the O(n²) brute-force approach."
}