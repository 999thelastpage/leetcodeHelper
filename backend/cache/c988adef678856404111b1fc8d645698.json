{
    "explanation": "### **Pattern Analysis**\n\nThe \"String to Integer (atoi)\" problem is a classic string parsing challenge. At its core, it's about simulating a process with a strict set of rules. This can be modeled as a finite state machine. We transition between states based on the character we are currently reading. The states are:\n\n1.  **Leading Whitespace:** Ignoring initial spaces.\n2.  **Sign Detection:** Looking for a `'+'` or `'-'`. \n3.  **Digit Conversion:** Reading and accumulating digit characters.\n4.  **End/Invalid:** Halting upon encountering a non-digit character or the end of the string.\n\nThis problem requires careful, sequential processing and meticulous handling of edge cases, which is a common pattern in implementation-heavy questions. The most critical sub-problem is detecting and handling integer overflow/underflow *before* it actually happens, a frequent pitfall in numerical computation problems.\n\n### **Intuition**\n\nLet's approach this as a human would read and interpret the string. Imagine you are given a string like `\"   -1234 abcd\"` and asked to find the integer it represents.\n\n1.  **Scan and Skip:** Your eyes would first scan past the leading spaces (`\"   \"`) until you hit the first meaningful character.\n\n2.  **Check for a Sign:** The first non-space character is `'-'`. You make a mental note: \"Okay, the number is going to be negative.\"\n\n3.  **Read the Digits:** You then start reading the digits one by one: '1', '2', '3', '4'. As you read them, you build the number in your head:\n    *   See '1': The number is 1.\n    *   See '2': The number becomes `1 * 10 + 2 = 12`.\n    *   See '3': The number becomes `12 * 10 + 3 = 123`.\n    *   See '4': The number becomes `123 * 10 + 4 = 1234`.\n\n4.  **Stop Reading:** The next character is a space `' '`. This is not a digit, so you stop the conversion process right there. You ignore the rest of the string (`\" abcd\"`).\n\n5.  **Apply Sign and Finalize:** You recall the number is negative. So, the final result is `-1234`.\n\nThe logic for a computer program will follow these exact steps. However, a computer has a limitation that we must explicitly handle: it works with fixed-size integers (32-bit in this case). A number like `9999999999999` is easy for us to read, but it would overflow a standard integer type. The core challenge is to build the number digit by digit while constantly checking if the next step would push the result outside the valid `[-2^31, 2^31 - 1]` range. If it would, we must \"clamp\" the result to the nearest boundary (`Integer.MIN_VALUE` or `Integer.MAX_VALUE`).\n\n### **Algorithm**\n\nWe will implement the logic described above in a structured, step-by-step manner. We will use an integer variable `result` to build up the number, but we will do all our calculations as if it's a positive number and only apply the sign at the very end. This simplifies the overflow/underflow logic.\n\n**1. Initialization**\n*   `index`: An integer to keep track of our current position in the string `s`. Initialize to `0`.\n*   `sign`: An integer to store the sign of the number. Initialize to `1` (positive).\n*   `result`: An integer to store the numerical value. Initialize to `0`.\n*   `n`: The length of the string `s`.\n\n**2. Handle Edge Case: Empty String**\n*   If `n` is 0, the string is empty. Return `0` immediately.\n\n**3. Step 1: Ignore Leading Whitespace**\n*   Use a `while` loop to advance `index` as long as it's within bounds and the character `s.charAt(index)` is a space `' '`.\n    ```java\n    while (index < n && s.charAt(index) == ' ') {\n        index++;\n    }\n    ```\n\n**4. Step 2: Determine Signedness**\n*   After skipping whitespace, check the character at the current `index` (if we haven't reached the end of the string).\n*   If `s.charAt(index)` is `'+'`, it's a positive number. Keep `sign = 1` and increment `index` to move past it.\n*   If `s.charAt(index)` is `'-'`, it's a negative number. Set `sign = -1` and increment `index`.\n    ```java\n    if (index < n && s.charAt(index) == '+') {\n        sign = 1;\n        index++;\n    } else if (index < n && s.charAt(index) == '-') {\n        sign = -1;\n        index++;\n    }\n    ```\n\n**5. Step 3 & 4: Convert Digits and Handle Overflow**\n*   This is the main loop. We iterate as long as `index` is within the string bounds and `s.charAt(index)` is a digit ('0' through '9').\n*   Inside the loop:\n    a. **Get Digit:** Convert the character to an integer: `int digit = s.charAt(index) - '0';`.\n\n    b. **Check for Overflow/Underflow:** This is the most critical part. Before we update our `result` with the new `digit`, we must check if doing so would exceed `Integer.MAX_VALUE`. The new result would be `result * 10 + digit`. \n    To check for overflow without causing an overflow, we rearrange the check `result * 10 + digit > Integer.MAX_VALUE`:\n    `result > (Integer.MAX_VALUE - digit) / 10`.\n    A more common and intuitive way to write this check is:\n    `if (result > Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10))`\n    Let's break this down:\n    *   `Integer.MAX_VALUE` is `2147483647`.\n    *   `Integer.MAX_VALUE / 10` is `214748364`.\n    *   `Integer.MAX_VALUE % 10` is `7`.\n    *   **First condition `(result > 214748364)`:** If our current `result` is already greater than `214748364`, multiplying it by 10 will surely result in a number larger than `Integer.MAX_VALUE`. \n    *   **Second condition `(result == 214748364 && digit > 7)`:** If our `result` is exactly `214748364`, then the final number depends on the `digit`. If the `digit` is greater than 7, the new number `2147483640 + digit` will be greater than `2147483647`.\n    *   If this overflow condition is met, we must clamp the result. We return `Integer.MAX_VALUE` if the `sign` is positive, and `Integer.MIN_VALUE` if the `sign` is negative.\n\n    c. **Update Result:** If the check passes, we can safely update the result:\n    `result = result * 10 + digit;`\n\n    d. **Move to Next Character:** Increment `index`.\n\n**6. Final Result**\n*   Once the loop terminates (either because we hit a non-digit or the end of the string), we have the final magnitude of the number in `result`.\n*   Apply the sign: `return sign * result;`.\n\nThis algorithm correctly handles all cases specified by the problem, including leading whitespace, signs, non-digit characters, and, most importantly, clamping for out-of-range values.\n\n### **Complexity Analysis**\n\n*   **Time Complexity:** O(N), where N is the length of the input string `s`. We perform a single pass through the string. The `index` pointer only ever moves forward, from the beginning to the end of the string, so each character is visited at most once.\n\n*   **Space Complexity:** O(1). We only use a few variables (`index`, `sign`, `result`, `n`) to store our state. The memory usage does not scale with the size of the input string, making it constant. This is an in-place conversion."
}