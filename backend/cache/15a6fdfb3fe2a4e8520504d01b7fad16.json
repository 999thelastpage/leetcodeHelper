{
    "explanation": "## In-Depth Analysis of Regular Expression Matching\n\nThis problem asks us to implement a simplified regular expression matcher that supports the standard character matching, the `.` wildcard, and the `*` quantifier. The matching must cover the entire input string `s`, not just a part of it. This is a classic problem that showcases the power of dynamic programming.\n\n### Pattern Analysis\n\nFirst, let's dissect the components of the pattern `p`:\n\n1.  **Literal Characters:** A lowercase English letter in the pattern (e.g., 'a', 'b', 'c') matches only that exact character in the string `s`.\n2.  **The `.` Wildcard:** This character matches *any single character* in the string `s`.\n3.  **The `*` Quantifier:** This is the most complex part. `*` is not a character to be matched on its own. Instead, it modifies the *preceding* element in the pattern. The problem guarantees that `*` will always have a preceding element. \n    *   `c*` means \"zero or more occurrences of the character `c`\". For example, `a*` can match `\"\"` (empty string), `\"a\"`, `\"aa\"`, `\"aaa\"`, and so on.\n    *   `.*` means \"zero or more occurrences of any character\". This is a very powerful pattern that can match any sequence of characters, including an empty one. For example, `.*` can match `\"\"`, `\"a\"`, `\"ab\"`, `\"hello world\"`, etc.\n\nBecause the state of our match depends on previous decisions (e.g., how many characters `*` matched), this problem has optimal substructure and overlapping subproblems, making it a perfect candidate for recursion with memoization or a bottom-up dynamic programming approach. We will focus on the bottom-up DP solution as it is generally more efficient and avoids potential stack overflow issues with deep recursion.\n\n### Intuition: From Recursion to Dynamic Programming\n\nImagine a function `match(i, j)` that tells us if the suffix of the string `s` starting at index `i` (i.e., `s[i:]`) matches the suffix of the pattern `p` starting at index `j` (i.e., `p[j:]`).\n\n-   **Base Case:** If we've reached the end of the pattern (`j == p.length()`), a match is successful only if we've also reached the end of the string (`i == s.length()`).\n\n-   **Recursive Step:** Let's consider `p[j]`. The logic branches depending on the character *after* `p[j]`, which is `p[j+1]`. \n\n    1.  **If `p[j+1]` is NOT `*`:** This is the simple case. We need a match at the current characters. A `first_match` occurs if `i < s.length()` and `p[j]` is either `.` or is equal to `s[i]`. If `first_match` is true, the overall result depends on the rest of the strings: `match(i+1, j+1)`.\n\n    2.  **If `p[j+1]` IS `*`:** This is the core challenge. The pattern part `p[j]*` gives us two choices:\n        *   **Zero-occurrence choice:** We can treat `p[j]*` as matching zero characters. In this case, we effectively skip this part of the pattern and see if the rest of the pattern `p[j+2:]` matches the current string `s[i:]`. This translates to a recursive call `match(i, j+2)`.\n        *   **One-or-more-occurrence choice:** If we use `p[j]*` to match one or more characters, we first need to ensure the current character `s[i]` matches `p[j]`. If it does (`first_match`), we consume the character from `s` and try to match `s[i+1:]` against the *same* pattern `p[j:]`. We stay at `j` because the `*` allows us to match even more characters. This translates to `first_match && match(i+1, j)`.\n\nThis recursive approach would work, but it would re-calculate `match(i, j)` for the same `i` and `j` multiple times, leading to exponential time complexity. To optimize this, we can store the results of these subproblems. This is memoization (top-down DP). An even cleaner way is to build the solution iteratively from the smallest subproblems to the largest, which is bottom-up DP.\n\n### The Bottom-Up Dynamic Programming Approach\n\nWe will use a 2D table, `dp`, to store the results of our subproblems.\n\n#### 1. DP State Definition\n\nLet `dp[i][j]` be a boolean value indicating whether the first `i` characters of the string `s` (i.e., `s.substring(0, i)`) match the first `j` characters of the pattern `p` (i.e., `p.substring(0, j)`).\n\n#### 2. DP Table Size\n\nThe table will have dimensions `(s.length() + 1) x (p.length() + 1)`. The `+1` is to accommodate the base case of an empty string or empty pattern prefix. So, `dp[0][0]` represents an empty string matching an empty pattern.\n\n#### 3. Initialization\n\n*   `dp[0][0] = true`: An empty string (`s` of length 0) matches an empty pattern (`p` of length 0). This is our anchor.\n*   **First Row (`dp[0][j]`):** We need to figure out which patterns can match an empty string. A pattern can only match an empty string if it's composed of elements like `x*`, which can represent zero occurrences. For example, `a*`, `a*b*`, `c*a*.*` can all match an empty string. \n    So, for `j` from 1 to `p.length()`, `dp[0][j]` is true if `p[j-1]` is `*` AND the pattern two characters before it also matched an empty string. The `*` effectively eliminates itself and the character before it. Therefore, `dp[0][j] = dp[0][j-2]`. \n*   **First Column (`dp[i][0]` for `i > 0`):** An empty pattern cannot match a non-empty string. So, `dp[i][0]` is `false` for all `i > 0`.\n\n#### 4. The Recurrence Relation\n\nWe will fill the rest of the table by iterating `i` from 1 to `s.length()` and `j` from 1 to `p.length()`. For each `dp[i][j]`, we look at the character `p[j-1]` (the `j`-th character of the pattern, which corresponds to index `j-1`).\n\n**Case 1: `p[j-1]` is a normal character or `.`**\n\nIf the pattern character is not a `*`, we need a direct match with the current string character `s[i-1]`. \n*   A match happens if `p[j-1] == s[i-1]` or `p[j-1] == '.'`.\n*   If they match, the result of `dp[i][j]` depends entirely on whether the prefixes *before* these characters matched. That is, did `s[0..i-2]` match `p[0..j-2]`? This is given by `dp[i-1][j-1]`.\n*   So, `dp[i][j] = (p[j-1] == s[i-1] || p[j-1] == '.') && dp[i-1][j-1]`.\n\n**Case 2: `p[j-1]` is `*`**\n\nThis is the complex case. The `*` at `p[j-1]` refers to the character `p[j-2]`. Let's call it `prev_char`. The `prev_char*` pair can be interpreted in two ways:\n\n*   **Zero Occurrences:** The `prev_char*` part matches an empty sequence. In this scenario, we are essentially ignoring this part of the pattern (`p[j-2]` and `p[j-1]`). The match for `dp[i][j]` would then depend on whether the string `s[0..i-1]` matches the pattern `p[0..j-3]`. This value is stored in `dp[i][j-2]`. This is our first possibility. `dp[i][j] = dp[i][j-2]`.\n\n*   **One or More Occurrences:** If `prev_char*` matches one or more characters, it means it must match the current string character `s[i-1]`. This is only possible if `s[i-1]` matches `prev_char` (i.e., `s[i-1] == prev_char` or `prev_char == '.'`).\n    If they do match, then `prev_char*` has successfully accounted for `s[i-1]`. Now, the problem reduces to whether the same pattern part `prev_char*` can match the rest of the string prefix, `s[0..i-2]`. So, we check if `s[0..i-2]` matches the current pattern `p[0..j-1]`. This value is stored in `dp[i-1][j]`.\n    This gives us the second possibility: `(s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j]`. \n\nCombining these two possibilities with an OR operator gives us the full recurrence for the `*` case:\n`dp[i][j] = dp[i][j-2] || ( (s[i-1] == p[j-2] || p[j-2] == '.') && dp[i-1][j] )`\n\n#### 5. Final Result\n\nThe final answer to the problem `s` matches `p` is stored in the bottom-right cell of our table: `dp[s.length()][p.length()]`.\n\n### Walkthrough Example: s = \"aab\", p = \"c*a*b\"\n\nLet `m = s.length() = 3`, `n = p.length() = 5`.\nWe create a `dp` table of size `4 x 6`.\n\n`s`: _ a a b\n`p`: _ c * a * b\n\n**Initialization:**\n`dp[0][0] = true` (empty string matches empty pattern)\n\n**Fill Row 0 (matching empty string `s`):**\n- `dp[0][1]` (p=\"c\"): false\n- `dp[0][2]` (p=\"c*\"): `p[1]` is `*`. Look at `dp[0][0]`. It's true. So `dp[0][2] = true`.\n- `dp[0][3]` (p=\"c*a\"): false\n- `dp[0][4]` (p=\"c*a*\"): `p[3]` is `*`. Look at `dp[0][2]`. It's true. So `dp[0][4] = true`.\n- `dp[0][5]` (p=\"c*a*b\"): false\n\nInitial `dp` table:\n```\n      p _ c * a * b\n  s\n  _\n  a\n  a\n  b\n\n      p _ c * a * b\n  s _ | T F T F T F\n  a   | F ? ? ? ? ?\n  a   | F ? ? ? ? ?\n  b   | F ? ? ? ? ?\n```\n\n**Fill the rest of the table:**\n\n`dp[1][1]`: s=\"a\", p=\"c\". `s[0]!=p[0]`. `false`.\n`dp[1][2]`: s=\"a\", p=\"c*\". `p[1]` is `*`. \n    - Zero occurrences: `dp[1][0]` -> `false`.\n    - One+ occurrences: `s[0]` ('a') vs `p[0]` ('c')? No match. \n    - So, `false || false` -> `false`.\n`dp[1][3]`: s=\"a\", p=\"c*a\". `p[2]` is 'a'. `s[0]` is 'a'. Match! Look at `dp[0][2]`. It's `true`. So `dp[1][3] = true`.\n`dp[1][4]`: s=\"a\", p=\"c*a*\". `p[3]` is `*`.\n    - Zero occurrences: `dp[1][2]` -> `false`.\n    - One+ occurrences: `s[0]` ('a') vs `p[2]` ('a')? Match! Look at `dp[0][4]`. It's `true`.\n    - So, `false || true` -> `true`.\n...and so on.\n\nAfter filling the entire table, it would look like this:\n```\n      p _ c * a * b\n  s _ | T F T F T F\n  a   | F F F T T F\n  a   | F F F F T F\n  b   | F F F F F T\n```\n\nThe final answer is `dp[3][5]`, which is **True**. This is correct.\n\n### Algorithm\n\nHere is the complete algorithm in pseudocode:\n\n```\nfunction isMatch(s, p):\n  m = s.length\n  n = p.length\n\n  // dp[i][j] will be true if s[0..i-1] matches p[0..j-1]\n  dp = new boolean[m + 1][n + 1]\n\n  // Base case: empty string vs empty pattern\n  dp[0][0] = true\n\n  // Initialize first row (empty string s vs pattern p)\n  for j from 1 to n:\n    if p[j-1] == '*' and j > 1:\n      dp[0][j] = dp[0][j-2]\n\n  // Fill the rest of the table\n  for i from 1 to m:\n    for j from 1 to n:\n      // Current characters to consider\n      s_char = s[i-1]\n      p_char = p[j-1]\n\n      if p_char == '.' or p_char == s_char:\n        // Standard match or wildcard match\n        dp[i][j] = dp[i-1][j-1]\n      else if p_char == '*':\n        // '*' case requires looking at the character BEFORE the '*' in p\n        p_prev_char = p[j-2]\n\n        // Option 1: '*' matches zero elements. \n        // We ignore p_prev_char and '*' and look at the result from p[0..j-3]\n        option1 = dp[i][j-2]\n\n        // Option 2: '*' matches one or more elements.\n        // This is only possible if s_char matches p_prev_char.\n        option2 = false\n        if p_prev_char == '.' or p_prev_char == s_char:\n          // If they match, we consume s_char and stay on the same pattern `*`\n          option2 = dp[i-1][j]\n        \n        dp[i][j] = option1 or option2\n      else:\n        // Mismatch\n        dp[i][j] = false\n\n  return dp[m][n]\n```\n\n### Complexity Analysis\n\n*   **Time Complexity:** `O(m * n)`, where `m` is the length of the string `s` and `n` is the length of the pattern `p`. We iterate through each cell of the `m x n` DP table once, and the work done inside each cell is constant time.\n\n*   **Space Complexity:** `O(m * n)`. We use a 2D array of size `(m+1) x (n+1)` to store the DP state. \n\n    *Space Optimization Note:* It's possible to optimize the space to `O(n)`. Notice that to compute row `i`, we only need results from row `i` (for the `*` case) and row `i-1`. This means we only need to store the previous row and the current row being computed. With careful implementation, this can be further optimized to a single `O(n)` array."
}