{
    "explanation": "### Pattern Analysis\nThis problem is a classic example of a \"search for a pair\" pattern. We are given a collection of elements (an array of numbers) and a target value. The goal is to find two elements in the collection that have a specific relationship — in this case, their sum equals the target. The core task is, for each element `x` in the array, to efficiently search for its corresponding complement, `y`, such that `x + y = target`. The complement `y` can be calculated as `target - x`.\n\nThe most naive approach would be to check every possible pair, which leads to a quadratic time complexity, O(n²). However, the need to perform repeated searches for a complement (`target - x`) strongly suggests the use of a data structure that provides fast lookups. The ideal choice for this is a **Hash Table** (also known as a Hash Map or Dictionary). A hash table offers, on average, O(1) time complexity for insertions and lookups, which is the key to optimizing this problem.\n\n### Intuition\nLet's build our intuition from the ground up, starting with the most basic approach and refining it until we reach the optimal solution.\n\n**1. The Brute-Force Approach**\n\nThe most straightforward way to solve this is to consider every possible pair of numbers in the array. We can use two nested loops. The outer loop iterates from the first element to the last, picking the first number of the pair, `nums[i]`. The inner loop iterates from the next element (`i + 1`) to the last, picking the second number, `nums[j]`. For each pair, we check if `nums[i] + nums[j] == target`. If it is, we've found our solution and can return their indices `[i, j]`.\n\n*   **Why is this suboptimal?** This approach has a time complexity of O(n²). For an array of size `n`, the outer loop runs `n` times, and the inner loop runs approximately `n` times in the worst case. With `n` up to 10⁴, `n²` could be up to 10⁸ operations, which is often too slow and would likely result in a \"Time Limit Exceeded\" error. The problem's follow-up explicitly asks for a solution better than O(n²).\n\n**2. Towards Optimization: The Need for Speed**\n\nThe bottleneck in the brute-force approach is the inner loop, which performs a linear search for the complement. For each `nums[i]`, we are looking for a value `complement = target - nums[i]`. Instead of scanning the rest of the array every time, what if we could find this complement almost instantly?\n\nThis is where a hash table comes in. A hash table stores key-value pairs and allows us to check for the existence of a key in O(1) average time. We can use this to our advantage. What should we store in the hash table? We need to look up a number and get its index. So, a perfect mapping would be `number -> index`.\n\n**3. The Two-Pass Hash Table Approach**\n\nWe can first build a complete map of all numbers to their indices and then iterate through the array a second time to find the solution.\n\n*   **Pass 1: Build the Map.** Iterate through the `nums` array once. For each element `nums[i]`, add an entry `{nums[i]: i}` to the hash table. If there are duplicate numbers, the map will only store the index of the last occurrence, which is fine for this problem's logic.\n*   **Pass 2: Find the Complement.** Iterate through the `nums` array again. For each element `nums[i]`, calculate `complement = target - nums[i]`. Now, look up this `complement` in the hash table. \n    *   If the `complement` exists in the map, and its stored index is not the current index `i` (to satisfy the constraint of not using the same element twice), we have found our solution. The indices are `i` and `map[complement]`. We can return `[i, map[complement]]`.\n\nThis approach works and is much faster. It involves two separate passes over the array, so the time complexity is O(n) + O(n) = O(n). The space complexity is O(n) to store the hash table. This is a great improvement!\n\n**4. The Optimal Solution: The One-Pass Hash Table Approach**\n\nCan we do even better and solve it in a single pass? Yes. We can combine the two steps above into one elegant pass.\n\nLet's iterate through the array just once. As we process each element `nums[i]`, we can perform two actions:\n\n1.  **Check for a solution:** Look back at the elements we have *already visited* to see if any of them is the complement of the current element.\n2.  **Store for the future:** Add the current element and its index to our hash table so that *subsequent* elements can find it if it's their complement.\n\nThe key insight is to check for the complement *before* adding the current number to the map. Let's trace this with an example: `nums = [2, 7, 11, 15]`, `target = 9`.\n\n*   Start with an empty map `map = {}`.\n*   **Index 0, Number 2:** The complement is `9 - 2 = 7`. Is `7` in the map? No, the map is empty. So, we add the current number `2` and its index `0` to the map. `map` is now `{2: 0}`.\n*   **Index 1, Number 7:** The complement is `9 - 7 = 2`. Is `2` in the map? Yes! Its value is `0`. We have found our pair: the current number `7` at index `1`, and the number `2` we saw earlier at index `0`. We can immediately return `[0, 1]`.\n\nThis one-pass approach works perfectly. By checking the map before inserting, we ensure that we are always finding a complement that appeared at an earlier index. This naturally prevents using the same element twice (i.e., `i` will never equal `map[complement]`) and simplifies the logic. Since the problem guarantees exactly one solution, we are sure to find a match and return from within the loop.\n\n### Algorithm\nHere is a step-by-step description of the one-pass hash table algorithm:\n\n1.  Initialize an empty hash map, let's call it `seen_map`, to store the numbers we have seen so far and their corresponding indices. The map will store `(number, index)` pairs.\n2.  Iterate through the input array `nums` using an index `i` from `0` to `n-1`, where `n` is the length of the array. Let the current number be `current_num = nums[i]`.\n3.  For each `current_num`, calculate its required complement: `complement = target - current_num`.\n4.  Check if this `complement` exists as a key in `seen_map`. \n    *   If `complement` is in `seen_map`, it means we have found the two numbers that sum up to the target. The index of the complement is `seen_map[complement]`, and the index of the current number is `i`. Return the list of these two indices: `[seen_map[complement], i]`.\n5.  If the `complement` is not found in `seen_map`, it means we haven't found a solution yet. Add the `current_num` and its index `i` to the `seen_map` to make it available for future elements to check against. Set `seen_map[current_num] = i`.\n6.  Continue the loop. Since the problem statement guarantees that exactly one solution exists, the function will always find a pair and return from step 4.\n\n### Complexity Analysis\n*   **Time Complexity: O(n)**\n    The algorithm involves a single pass through the `nums` array, which has `n` elements. Inside the loop, the operations are: a subtraction, a hash table lookup, and potentially a hash table insertion. On average, hash table lookups and insertions take constant time, O(1). Therefore, the total time complexity is dominated by the single loop, making it O(n).\n\n*   **Space Complexity: O(n)**\n    The algorithm uses a hash table to store the numbers encountered. In the worst-case scenario, we might have to store up to `n-1` elements in the hash table before finding a solution (for example, if the solution pair is the last two elements of the array). Thus, the extra space required is proportional to the number of elements in the input array, resulting in a space complexity of O(n)."
}